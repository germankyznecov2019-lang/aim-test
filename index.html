<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Face AR Ultra</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: -apple-system, sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        
        video { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); /* Зеркалим по умолчанию */
        }
        
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* Вспышка (белый экран) */
        .flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.2s;
            mix-blend-mode: overlay; z-index: 10;
        }

        /* UI: Кнопки */
        .controls {
            position: absolute; bottom: 40px; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 25px; z-index: 50;
        }

        .btn {
            background: rgba(20, 20, 20, 0.4);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%; width: 64px; height: 64px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: 0.2s; -webkit-tap-highlight-color: transparent;
        }
        .btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }
        .btn svg { width: 30px; height: 30px; fill: white; }

        /* UI: Статус */
        .hud-status {
            position: absolute; top: 12%; left: 50%; transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8); font-size: 12px; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0,0,0,0.5); font-weight: 600;
            display: flex; gap: 10px; align-items: center;
        }
        .dot { width: 8px; height: 8px; background: red; border-radius: 50%; box-shadow: 0 0 10px red; }
        .dot.active { background: #00ffcc; box-shadow: 0 0 10px #00ffcc; }

        /* Загрузчик */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00ffcc; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">
        <h3 style="margin-bottom: 20px;">Загрузка AI...</h3>
        <div style="width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #00ffcc; border-radius: 50%; animation: spin 1s infinite linear;"></div>
    </div>

    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <div class="flash-overlay" id="flash"></div>
        <canvas id="canvas"></canvas>
        
        <div class="hud-status">
            <div class="dot" id="status-dot"></div>
            <span id="status-text">SYSTEM READY</span>
        </div>

        <div class="controls">
            <div class="btn" onclick="switchCam()">
                <svg viewBox="0 0 24 24"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z"/></svg>
            </div>
            <div class="btn" onclick="toggleFlash()">
                <svg viewBox="0 0 24 24"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7z"/></svg>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>@keyframes spin { 100% { transform: rotate(360deg); } }</style>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const loader = document.getElementById('loader');
        const statusDot = document.getElementById('status-dot');
        
        let facingMode = 'user';
        let isFlash = false;
        
        // --- МАГИЯ ПЛАВНОСТИ (Lerp) ---
        // Мы храним ТЕКУЩИЕ координаты (отображаемые) и ЦЕЛЕВЫЕ (куда лицо переместилось)
        let currentBox = { x: 0, y: 0, w: 0, h: 0, active: false };
        let targetBox = { x: 0, y: 0, w: 0, h: 0, active: false, lastUpdate: 0 };
        
        // Настройки AI: 224 пикселя - это быстрее, меньше лагов
        const OPT = new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.35 });

        async function init() {
            try {
                await faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
                startCam();
            } catch(e) { alert("Error: " + e); }
        }

        async function startCam() {
            if(video.srcObject) video.srcObject.getTracks().forEach(t=>t.stop());
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }
            });
            video.srcObject = stream;
            video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
            
            video.onloadedmetadata = () => {
                video.play();
                loader.style.opacity = 0;
                setTimeout(()=>loader.style.display='none', 500);
                
                // Запускаем два независимых цикла
                loopDetection(); // Медленный (AI)
                loopDrawing();   // Быстрый (UI 60 FPS)
            };
        }

        // 1. ЦИКЛ ДЕТЕКЦИИ (Работает так быстро, как может процессор, обновляет ЦЕЛЬ)
        async function loopDetection() {
            if(video.paused || video.ended) return setTimeout(loopDetection, 100);
            
            const displaySize = { width: video.clientWidth, height: video.clientHeight };
            // Важно: не вызываем matchDimensions каждый кадр, это дорого. Делаем это при ресайзе.
            
            const detections = await faceapi.detectAllFaces(video, OPT);
            
            if (detections.length > 0) {
                // Берем самое большое лицо
                const d = faceapi.resizeResults(detections, displaySize)[0];
                const box = d.box;

                // Если фронталка - зеркалим координаты для логики
                let targetX = box.x;
                if(facingMode === 'user') {
                    targetX = displaySize.width - (box.x + box.width);
                }

                // Обновляем цель
                targetBox = {
                    x: targetX,
                    y: box.y,
                    w: box.width,
                    h: box.height,
                    active: true,
                    lastUpdate: Date.now()
                };
                
                statusDot.className = "dot active";
            } else {
                // Если лицо потеряно, держим старую позицию пару секунд, потом скрываем
                if(Date.now() - targetBox.lastUpdate > 1000) {
                    targetBox.active = false;
                    statusDot.className = "dot";
                }
            }
            
            // Запускаем следующий поиск сразу же
            setTimeout(loopDetection, 0);
        }

        // 2. ЦИКЛ ОТРИСОВКИ (Работает всегда 60 FPS)
        function loopDrawing() {
            const ctx = canvas.getContext('2d');
            canvas.width = video.clientWidth;
            canvas.height = video.clientHeight;
            ctx.clearRect(0,0, canvas.width, canvas.height);

            // ЛИНЕЙНАЯ ИНТЕРПОЛЯЦИЯ (LERP)
            // Двигаем текущий круг к цели на 20% дистанции каждый кадр.
            // Это создает эффект "магнита" и убирает дрожание.
            const smoothSpeed = 0.25; // 0.1 - очень плавно/медленно, 0.5 - быстро/резко

            if (targetBox.active) {
                // Если это первое обнаружение - телепортируем круг сразу
                if (!currentBox.active) {
                    currentBox = { ...targetBox };
                    currentBox.active = true;
                }

                // Плавное приближение координат
                currentBox.x += (targetBox.x - currentBox.x) * smoothSpeed;
                currentBox.y += (targetBox.y - currentBox.y) * smoothSpeed;
                currentBox.w += (targetBox.w - currentBox.w) * smoothSpeed;
                currentBox.h += (targetBox.h - currentBox.h) * smoothSpeed;

                // Рисуем КРУТОЙ интерфейс
                const cx = currentBox.x + currentBox.w / 2;
                const cy = currentBox.y + currentBox.h / 2;
                const r = currentBox.w / 1.6; // Радиус

                // Внешнее свечение
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#00ffcc";
                
                // Основной круг
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.lineWidth = 3;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                ctx.stroke();

                // Декоративные скобки по бокам (HUD стиль)
                ctx.shadowBlur = 0; // Убираем свечение для деталей
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Левая скобка
                ctx.arc(cx, cy, r + 15, Math.PI * 0.7, Math.PI * 1.3);
                ctx.stroke();
                // Правая скобка
                ctx.beginPath();
                ctx.arc(cx, cy, r + 15, Math.PI * 1.7, Math.PI * 0.3);
                ctx.stroke();

            } else {
                currentBox.active = false;
            }

            requestAnimationFrame(loopDrawing);
        }

        // --- Управление ---
        function switchCam() {
            facingMode = facingMode === 'user' ? 'environment' : 'user';
            startCam();
        }
        function toggleFlash() {
            isFlash = !isFlash;
            document.getElementById('flash').style.opacity = isFlash ? 0.8 : 0;
            // Попытка включить реальный фонарик
            const track = video.srcObject?.getVideoTracks()[0];
            if(track) track.applyConstraints({ advanced: [{ torch: isFlash }] }).catch(e=>{});
        }
        
        window.addEventListener('resize', () => {
             // Просто обновляем размер канваса в следующем кадре отрисовки
        });

        init();
    </script>
</body>
</html>
