<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI Face Tracker HUD</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace; /* Техно-шрифт */
        }

        /* Контейнер для видео и канваса */
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Видео скрыто, мы рисуем его на канвасе или используем как подложку */
        .input_video {
            display: none;
        }

        /* Канвас поверх всего */
        .output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        /* UI Слой (HUD) */
        .hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Чтобы клики проходили сквозь интерфейс */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Стеклянный интерфейс (Glassmorphism) */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px;
            color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: all 0.3s ease;
        }

        /* Верхняя панель */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 10px #0f0;
            animation: pulse 2s infinite;
        }

        /* Нижняя панель */
        .bottom-stats {
            display: flex;
            justify-content: space-around;
            height: 80px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .stat-label {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
        }

        /* Анимация пульсации */
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Загрузочный экран */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 14px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="loader">INITIALIZING AI SYSTEM...</div>

    <div class="container">
        <video class="input_video" playsinline muted></video>
        <canvas class="output_canvas"></canvas>

        <div class="hud-layer">
            <div class="top-bar glass-panel">
                <div class="status-indicator">
                    <div class="dot"></div>
                    SYSTEM ONLINE
                </div>
                <div style="font-size: 10px; opacity: 0.6;">120HZ TARGET</div>
            </div>

            <div class="bottom-stats glass-panel">
                <div class="stat-item">
                    <div class="stat-value" id="fps-counter">0</div>
                    <div class="stat-label">FPS</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="conf-score">0%</div>
                    <div class="stat-label">ACCURACY</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>

    <script>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const fpsOutput = document.getElementById('fps-counter');
        const confOutput = document.getElementById('conf-score');
        const loader = document.getElementById('loader');

        // Переменные для сглаживания (Lerp)
        let currentX = 0, currentY = 0, currentR = 0;
        let targetX = 0, targetY = 0, targetR = 0;
        // Коэффициент сглаживания (0.1 - очень плавно/медленно, 0.3 - быстрее)
        const smoothFactor = 0.2; 
        
        let lastFrameTime = 0;
        let isFaceDetected = false;

        function onResults(results) {
            // Убираем загрузчик после первого кадра
            if (loader.style.display !== 'none') loader.style.display = 'none';

            // Настраиваем размеры канваса под экран
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;

            // 1. Рисуем само видео с камеры
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Отражаем видео по горизонтали (как в зеркале) для удобства
            canvasCtx.translate(canvasElement.width, 0);
            canvasCtx.scale(-1, 1);
            
            // Рисуем изображение с камеры, растягивая на весь экран (object-fit: cover logic)
            drawImageProp(canvasCtx, results.image, 0, 0, canvasElement.width, canvasElement.height);

            // 2. Логика обнаружения лица
            if (results.detections.length > 0) {
                isFaceDetected = true;
                const detection = results.detections[0];
                const bbox = detection.boundingBox;
                const score = detection.categories[0].score;

                // Обновляем UI точности
                confOutput.innerText = Math.round(score * 100) + '%';

                // Вычисляем координаты (MediaPipe дает от 0.0 до 1.0)
                // Нам нужно перевести это в пиксели канваса.
                // Поскольку мы делаем "cover", расчеты сложнее, но для простоты берем по ширине/высоте канваса
                
                // Центр лица
                const faceCenterX = bbox.xCenter * canvasElement.width;
                const faceCenterY = bbox.yCenter * canvasElement.height;
                
                // Радиус (берем половину ширины или высоты, что больше)
                const faceRadius = (Math.max(bbox.width, bbox.height) * canvasElement.width) / 1.6; // 1.6 чтобы круг был чуть больше лица

                // Задаем цели для анимации
                targetX = faceCenterX;
                targetY = faceCenterY;
                targetR = faceRadius;

            } else {
                isFaceDetected = false;
                confOutput.innerText = "SRCH";
                // Если лицо потеряно, можно плавно убрать круг в 0 или оставить на последнем месте
                targetR = 0; 
            }

            // 3. Математика сглаживания (Linear Interpolation)
            // Это делает движения "как по маслу" (120fps feel)
            currentX = currentX + (targetX - currentX) * smoothFactor;
            currentY = currentY + (targetY - currentY) * smoothFactor;
            currentR = currentR + (targetR - currentR) * smoothFactor;

            // 4. Рисуем HUD графику
            if (currentR > 5) { // Рисуем только если радиус больше 5px
                
                // Белый круг
                canvasCtx.beginPath();
                canvasCtx.arc(currentX, currentY, currentR, 0, 2 * Math.PI);
                canvasCtx.lineWidth = 4;
                canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                canvasCtx.shadowBlur = 15;
                canvasCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                canvasCtx.stroke();

                // Тонкий декоративный круг внутри
                canvasCtx.beginPath();
                canvasCtx.arc(currentX, currentY, currentR * 1.1, 0, 2 * Math.PI); // Чуть больше
                canvasCtx.lineWidth = 1;
                canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                canvasCtx.stroke();
                
                // Перекрестие
                const crossSize = 10;
                canvasCtx.beginPath();
                canvasCtx.moveTo(currentX - crossSize, currentY);
                canvasCtx.lineTo(currentX + crossSize, currentY);
                canvasCtx.moveTo(currentX, currentY - crossSize);
                canvasCtx.lineTo(currentX, currentY + crossSize);
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                canvasCtx.stroke();
            }

            canvasCtx.restore();

            // Счетчик FPS
            const now = performance.now();
            const fps = 1000 / (now - lastFrameTime);
            lastFrameTime = now;
            if (now % 10 < 1) fpsOutput.innerText = Math.round(fps); // Обновляем не каждый кадр, чтобы не мелькало
        }

        // Настройка FaceDetection
        const faceDetection = new FaceDetection({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
        }});

        faceDetection.setOptions({
            modelSelection: 1, // 0 - для близкого расстояния (быстрее), 1 - дальнего (точнее)
            minDetectionConfidence: 0.6
        });

        faceDetection.onResults(onResults);

        // Запуск камеры
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceDetection.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: "user" // Фронтальная камера
        });
        
        // Вспомогательная функция для имитации object-fit: cover на canvas
        function drawImageProp(ctx, img, x, y, w, h, offsetX, offsetY) {
            if (arguments.length === 2) {
                x = y = 0;
                w = ctx.canvas.width;
                h = ctx.canvas.height;
            }
            offsetX = typeof offsetX === "number" ? offsetX : 0.5;
            offsetY = typeof offsetY === "number" ? offsetY : 0.5;

            if (offsetX < 0) offsetX = 0;
            if offsetY < 0) offsetY = 0;
            if (offsetX > 1) offsetX = 1;
            if (offsetY > 1) offsetY = 1;

            var iw = img.width,
                ih = img.height,
                r = Math.min(w / iw, h / ih),
                nw = iw * r,
                nh = ih * r,
                cx, cy, cw, ch, ar = 1;

            if (nw < w) ar = w / nw;
            if (Math.abs(ar - 1) < 1e-14 && nh < h) ar = h / nh;
            nw *= ar;
            nh *= ar;

            cw = iw / (nw / w);
            ch = ih / (nh / h);

            cx = (iw - cw) * offsetX;
            cy = (ih - ch) * offsetY;

            if (cx < 0) cx = 0;
            if (cy < 0) cy = 0;
            if (cw > iw) cw = iw;
            if (ch > ih) ch = ih;

            ctx.drawImage(img, cx, cy, cw, ch,  x, y, w, h);
        }

        camera.start();
    </script>
</body>
</html>
